Concurrency Control in Transactions
-----------------------------------

Authors: Mariana Bustamante - marianabb@gmail.com
         Rodrigo Gumucio - rgumucio@gmail.com


Based on code written by: 
      Noomene BenHenda - Noomene.BenHenda@it.uu.se


First Task: Concurrency Control Solution:
-----------------------------------------
* Algorithm implemented: Timestamps concurrency control.

* Structures Used:
  - A dictionary to handle object's timestamps. Every object
  is mapped by the variable name and contains information on its
  value, read timestamp and write timestamp.
  - A tree to manage the transactions requested. The transactions
  are ordered according to timestamps. Each transaction contains
  the following information: Client, Status, Dependencies, Modified
  Objects.
  - Dependencies contains the transactions for whom this transaction
  must wait before ending its execution. It is implemented as a dictionary
  in which every element is {Transaction U, Status of U},
  - Modified Objects contains the objects that the transaction is attempting
  to modify, their old timestamp, old value and the new value that the transaction 
  will attempt to commit. Modified Objects is also a dictionary in which
  objects are mapped according to their name. This structure is managed
  in the function object_manager.
  - In order to make managing of dependencies easier there is also a tree
  with elements in the form {Key, Value}, in which the Key is the timestamp
  of a transaction and Value is a queue of transactions that depend on 
  the transaction represented by Key. This structured is managed in
  the function dependency_manager.

* A new module was added called Counter. It contains a simple counter to
  generate and handle timestamps.

* Important functions:
  - Every action is handled in a separate function called by server_loop
  in order to make the code more readable. This functions are do_read, 
  do_write, do_commit and do_confirm. They receive the current state 
  of transactions, apply the rules and return the resulting tree of 
  transactions and the resulting status to be handled by the server.
  - The function propagate_event is used to propagate a commit/abort event
  of a transaction to the queue of transactions that depend on it.
  
  
Second Task: Handling Lost Messages:
------------------------------------
The following changes were added in order to handle loss of messages:
* Client Side:
  - The action messages now include a number that indicates its order
  inside each transaction and a variable that indicates if this is the
  first attempt of sending this message or a re-sending.
  - The client now receives a message {resend, MsgNr, ServerPid}. After
  this message is received the client must re-send all the actions
  starting from the one at position MsgNr to the server.
  - If the client has sent a confirm message, but has not received response 
  for 6 seconds it re-sends the confirm message.
  - Since the position of the confirm message in a transaction is
  always the same (could be considered as the last action, the client 
  also enumerates this message in order for the server to notice if
  messages have been lost before a confirm is received.

* Server Side:
  - Each transaction now contains two extra variables: Next and Resend.
  - Next indicates which action is the server waiting for in this transaction,
  any other action will be ignored and a 'resend' message is sent 
  depending on the variable Resend.
  - Resend is used to indicate to the server if a resend message for the
  missing action has already been sent. The goal is to try to reduce the 
  number of resend messages sent to the client (since the client always
  tries to resend the entire list of messages).
  - Other changes were made in order to handle redundant messages.


